name: Build, Test and Deploy

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  DOCKER_REGISTRY: ghcr.io
  SQL_PASSWORD: ${{ secrets.DB_PASSWORD }}
  REDIS_HOST: redis

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET Core
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Debug - Show project structure
        run: |
          echo "📁 Current directory structure:"
          find . -name "*.csproj" -o -name "*.sln" -o -name "*.fsproj" | sort
          echo ""
          echo "📁 Root directory files:"
          ls -la
          echo ""
          echo "🔍 Dockerfile check:"
          if [ -f "Dockerfile" ]; then
            echo "✅ Dockerfile exists"
            head -20 Dockerfile
          else
            echo "❌ Dockerfile not found"
            find . -name "Dockerfile" | sort
          fi

      - name: Restore dependencies
        run: |
          # Try to restore using solution file if exists
          if [ -f "*.sln" ]; then
            dotnet restore
          else
            # Find and restore csproj files
            for csproj in $(find . -name "*.csproj" -type f); do
              echo "Restoring: $csproj"
              dotnet restore "$csproj"
            done
          fi

      - name: Build
        run: dotnet build --configuration Release --no-restore

      - name: Run tests
        run: dotnet test --verbosity normal

      - name: Verify Docker Compose
        run: |
          if [ -f "docker-compose.yml" ] || [ -f "docker-compose.yaml" ]; then
            docker compose config
          else
            echo "No docker-compose file found, skipping..."
          fi

  deploy-docker-compose:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Convert repository name to lowercase
        run: |
          REPO_NAME="${{ github.repository }}"
          IMAGE_NAME_LOWER=$(echo "$REPO_NAME" | tr '[:upper:]' '[:lower:]')
          echo "Original: $REPO_NAME"
          echo "Lowercase: $IMAGE_NAME_LOWER"
          echo "IMAGE_NAME_LOWER=$IMAGE_NAME_LOWER" >> $GITHUB_ENV
          echo "FULL_IMAGE_TAG=ghcr.io/$IMAGE_NAME_LOWER" >> $GITHUB_ENV

      - name: Ensure Dockerfile exists
        run: |
          if [ ! -f "Dockerfile" ]; then
            echo "⚠️ Dockerfile not found, creating default Dockerfile..."
            
            # Find the first csproj file to use as project name
            CSPROJ_FILE=$(find . -name "*.csproj" -type f | head -1)
            
            if [ -z "$CSPROJ_FILE" ]; then
              echo "❌ No .csproj files found!"
              exit 1
            fi
            
            PROJECT_NAME=$(basename "$CSPROJ_FILE" .csproj)
            
            cat > Dockerfile << EOF
# Build stage
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# Copy csproj and restore
COPY ["$CSPROJ_FILE", "./"]
RUN dotnet restore "./$(basename $CSPROJ_FILE)"

# Copy everything else and build
COPY . .
WORKDIR "/src"
RUN dotnet build "./$(basename $CSPROJ_FILE)" -c Release -o /app/build

# Publish stage
FROM build AS publish
RUN dotnet publish "./$(basename $CSPROJ_FILE)" -c Release -o /app/publish /p:UseAppHost=false

# Runtime stage
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
WORKDIR /app
EXPOSE 80
EXPOSE 443
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "$PROJECT_NAME.dll"]
EOF
            
            echo "✅ Created Dockerfile for project: $PROJECT_NAME"
            cat Dockerfile
          else
            echo "✅ Dockerfile already exists"
          fi

      - name: Debug - Show Dockerfile content
        run: |
          echo "📄 Dockerfile content:"
          echo "======================"
          cat Dockerfile
          echo "======================"

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.FULL_IMAGE_TAG }}:latest
            ${{ env.FULL_IMAGE_TAG }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_CONFIGURATION=Release
          # Enable debugging output
          provenance: false
          # Don't fail if cache not found
          no-cache-filters: true

      - name: Test Docker Compose locally
        run: |
          echo "🔧 Testing Docker Compose locally..."
          
          # Create a simple test docker-compose file
          cat > docker-compose.test.yml << EOF
version: '3.8'
services:
  sqlserver:
    image: mcr.microsoft.com/mssql/server:2022-latest
    environment:
      SA_PASSWORD: "Test@Password123"
      ACCEPT_EULA: "Y"
      MSSQL_PID: "Express"
    ports:
      - "1433:1433"
    healthcheck:
      test: ["CMD-SHELL", "/opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P 'Test@Password123' -Q 'SELECT 1' || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  api:
    image: ${{ env.FULL_IMAGE_TAG }}:latest
    depends_on:
      sqlserver:
        condition: service_healthy
      redis:
        condition: service_started
    environment:
      ConnectionStrings__DefaultConnection: "Server=sqlserver;Database=master;User Id=sa;Password=Test@Password123;Encrypt=True;TrustServerCertificate=True;"
      ConnectionStrings__RadisConnection: "redis:6379"
      ASPNETCORE_ENVIRONMENT: "Development"
    ports:
      - "8080:80"
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:80/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
EOF
          
          echo "🚀 Starting services..."
          docker compose -f docker-compose.test.yml up -d
          
          echo "⏳ Waiting for services to start..."
          sleep 30
          
          echo "📊 Checking service status..."
          docker compose -f docker-compose.test.yml ps
          
          echo "🧪 Testing API connectivity..."
          if docker compose -f docker-compose.test.yml exec -T api curl -f http://localhost:80/health 2>/dev/null; then
            echo "✅ API health check passed!"
          else
            echo "⚠️ API health check failed (might still be starting)"
          fi
          
          echo "🧹 Cleaning up..."
          docker compose -f docker-compose.test.yml down
          
          echo "✅ Local Docker Compose test completed!"

      - name: Verify pushed image
        run: |
          echo "🔍 Verifying image was pushed..."
          echo "Image: ${{ env.FULL_IMAGE_TAG }}:latest"
          docker pull ${{ env.FULL_IMAGE_TAG }}:latest 2>/dev/null && echo "✅ Image pulled successfully!" || echo "⚠️ Could not pull image (might need time to propagate)"